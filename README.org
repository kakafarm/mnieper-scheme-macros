#+TITLE: Extending a Language --- Writing Powerful Macros in Scheme
#+AUTHOR: Marc Nieper-Wi√ükirchen
#+EMAIL: marc@nieper-wisskirchen.de

#+PROPERTY: header-args:scheme :session *session*

* Preface

This document is an introduction to writing powerful macros in Scheme.
It was initially written on the occasion of a tutorial I give at the
[[https://bobkonf.de/2023/en/][BOB2023 Konferenz]] in Berlin on 17 March 2023.

The macro facility, especially its built-in /hygiene/, is one of the
fundamental pillars of the Scheme programming language.  While more
complicated than the simple token-replacing macros of other languages
like C, Scheme macros can be written in a way that make them robust
and so that the abstractions they offer seamless blend into the
language and cannot be distinguished from syntactic forms built into
the language.  It is often felt that this expressiveness makes writing
Scheme macros more complicated (even something of a black art) than
writing C or Common Lisp macros, for example.  One goal of this
tutorial is to convince the audience otherwise.

While the Scheme macro facility has always been avant-garde (and this
is one of the reasons why Scheme was chosen as the implementation
language for this tutorial), a lot of what is said here also applies
to languages that provide corresponding features.  It is also a appeal
to language designers that languages should include a macro facility
as Scheme does, as this allows for small language cores and enables
the user to provide their own syntactic abstractions.

Another reason why the Scheme language is used in this tutorial is
that it has an exceptionally clear semantics, is a compact language,
and is easy to learn.

The document can both be read as is or used interactively in an Emacs
session.  In the following section, a possible setup is described.

* Prerequisites

** Chez Scheme

We need a Scheme implementation.  This tutorial assumes [[https://cisco.github.io/ChezScheme/][Chez Scheme]],
which is one of the most mature, standard-compliant Scheme
implementations.  You can get Chez Scheme from its homepage.  On
Debian-based GNU/Linux system like Ubuntu, it is prepackaged.

** Emacs

We will use [[https://www.gnu.org/software/emacs/][GNU Emacs]] as our development environment, which has great
tooling for Scheme.  The typical GNU/Linux system ships with it.

For GNU Emacs < 28, enable the [[https://elpa.nongnu.org/][NonGNU Emacs Lisp Package Archive]] in
your [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Init-File.html][init file]] or [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Easy-Customization.html][customize]] the variable ~package-archives~.

** Org

[[https://orgmode.org/][Org Mode]] is a GNU Emacs major mode that allows to document, edit and
execute source code.

The current versions of Org packaged with Emacs hide Scheme evaluation
errors.  This is fixed in the version in Org's git repository, for
which Org [[https://orgmode.org/org.html#Installation][provides installation instructions]].

Familiarize yourself with how one works with [[https://orgmode.org/org.html#Working-with-Source-Code][source code in an Org
document]], especially how to [[https://orgmode.org/org.html#Editing-Source-Code][edit]] and [[https://orgmode.org/org.html#Evaluating-Code-Blocks][execute code]].

** Geiser

[[https://www.nongnu.org/geiser/][Geiser]] is a GNU Emacs package that allows to runs Scheme processes in
GNU Emacs, and which is used by Org's Babel.  To install it, it is
enough to install the package [[https://gitlab.com/emacs-geiser/chez/-/blob/master/geiser-chez.el][geiser-chez]] using GNU Emacs' [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Package-Menu.html][package
menu]].  We need the most recent version.

** Paredit

[[https://paredit.org/][Paredit]], a tool for parenthetical editing in Emacs makes working with
Scheme code a lot more pleasant.  Like Geiser, it can be installed
through GNU Emacs' package manager.

** Initialization

After the GNU Emacs packages have been installed, we want to customize
them for our needs.  The following should go into your init file
unless you want to execute the following code every time you start GNU
Emacs.

#+BEGIN_SRC emacs-lisp :results none
  (require 'compile)
  (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code" t)
  (add-hook 'scheme-mode-hook #'enable-paredit-mode)
  (show-paren-mode t)
  (setq auto-mode-alist (cons '("\\.ss" . scheme-mode) auto-mode-alist))
  (setq auto-mode-alist (cons '("\\.sls" . scheme-mode) auto-mode-alist))
  (setq auto-mode-alist (cons '("\\.sps" . scheme-mode) auto-mode-alist))
  (add-to-list 'compilation-error-regexp-alist
               '("^\\(Exception\\|Warning\\).*: .* \\(line \\([0-9]+\\), char \\([0-9]+\\) of \\(.*\\)\\)" 5 3 4 nil 2))
  (setq geiser-default-implementation 'chez)
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((scheme . t)))
  (setq org-confirm-babel-evaluate nil)
#+END_SRC

* The Scheme programming language

Scheme is programming language of the Lisp family.  Its defining
properties are its uniform parenthesized syntax (inherited from Lisp),
first-class procedures and continuations, lexical scoping, dynamic
typing, proper tail calls and hygienic macros.  It is primarly a
functional programming language but allows many other programming
paradigms.

The Scheme programming language was developed in the 1970s by Guy
L. Steele and Gerald Jay Sussman.  Since then it has been refined and
further developed through a series of de facto standards called the
Revised^{/n/} Report(s) on the Algorithmic Language Scheme (R/n/RS).
The two current standards are R6RS (2007) and R7RS-small (2013).
Despite the versioning and the timeline, R6RS is the more detailed,
more advanced and more modern standard[fn:1].

In this tutorial, we work with the macro facility of R6RS, which is
far more powerful than the one of R7RS-small, and also discuss some
proposed or implemented extensions.  Such extensions to the Scheme
programming language are often proposed, discussed and implemented
using the [[https://srfi.schemers.org/][Scheme Requests for Implementation]] process, where everyone
can submit a /SRFI/ extending the Scheme programming language.

For practical programming, one needs, of course, an implementation.
Scheme is possibly the programming language with the highest number of
implementations.  The R6RS language has some very high-quality
implementations, including [[https://cisco.github.io/ChezScheme/][Chez Scheme]], [[https://www.gnu.org/software/guile/][GNU Guile]], [[https://scheme.fail/][Loko Scheme]], and [[https://racket-lang.org/][Racket]],
so for any application area, there will be a suitable Scheme system.

* TODO Some simple macros

Let us call a /combination/ an expression in Scheme of the form

#+BEGIN_SRC scheme :eval no
  (operator operand ...)
#+END_SRC

An example is given by the following expression evaluating to the answer of life:

#+BEGIN_SRC scheme :exports both :wrap example
  (* 21 2)
#+END_SRC

#+RESULTS:
#+begin_example
42
#+end_example

Such a combination is usually evaluated by evaluating the operator and
the operands in some unspecific order and by then calling the
procedure resulting from the operator evaluation with arguments
resulting from the operand evaluations.

Scheme, however, also possesses special forms, which do not follow
this evaluation strategy.  An example is given by the conditional ~if~.
#+BEGIN_SRC scheme :exports both :wrap example
  (if (number? 2)
      'ok
      (/ 1 0))
#+END_SRC

#+RESULTS:
#+begin_example
ok
#+end_example

If the conditional were a normal combination, the operands, and ~(/ 1
0)~ in particular, would have been evaluated first (and
unconditionally).  Scheme recognizes special forms through the
operator in first position, namely if it is a keyword (a special type
of identifier).  The Scheme macro facility allows the programmer to
define their own keywords.

** Incrementing a variable

Let us ignore for a moment that mutation is frowned upon in functional
programming and let us assume that we have to frequently increase the
value of variables in our program.  Given a variable ~x~, this is done
in Scheme through the following expression:
#+BEGIN_SRC scheme :eval no
  (set! x (+ x 1))
#+END_SRC
That the variable ~x~ is repeated in this expression is unpleasant
(and may be considered a violation of the DRY principle), so we want
an operator akin to C's pre/post-increment operator.  Unfortunately,
Scheme does not provide such an operator, but, fortunately, it doesn't
have to because we can build one ourself.

Our first attempt could be to write a procedure (the primary means of
abstraction in functional programming languages)[fn:4]:
#+BEGIN_SRC scheme :results silent
  (define incr!
    (lambda (x)
      (set! x (+ x 1))))
#+END_SRC

This attempt, however, is failed:
#+BEGIN_SRC scheme :exports both :wrap example
  (define x 1)
  (incr! x)
  x
#+END_SRC

#+RESULTS:
#+begin_example
1
#+end_example

The reason that it doesn't work --- the variable's value is still 1
and not 2 --- is that ~(incr! x)~ is a normal combination as
introduced earlier.  As the arguments are evaluated first and the
procedure is called with their values, in this example, ~incr!~ is
called with the argument ~1~.  This is then bound to a new variable
~x~ locally to ~incr!~.  It is this variable, which is increased by 1
and not the top-level variable.

The solution is, of course, to define ~incr!~ not as a procedure[fn:2]
but as a keyword.  In the Scheme programming language, the
~define-syntax~ keyword can be used for it:

#+BEGIN_SRC scheme :exports :results silent
  (define-syntax incr!
    (syntax-rules ()
      ((incr! x)
       (set! x (+ x 1)))))
#+END_SRC

This definition says that ~incr!~ is defined to be a new keyword,
implemented as a macro.  The ~syntax-rules~ line shall be viewed as
boilerplate for the moment (and we will come back to it later).
Important are the next two lines.  The form ~(incr! x)~ is a pattern
saying that the macro matches against a use of the form ~(keyword
form)~ (where ~keyword~ is necessarily ~incr!~).  When the macro is
used, the pattern variable ~x~ is bound to the ~form~.  The form
~(set! x (+ x 1))~ is a template.  When the macro is used, the pattern
variables in the template are replaced with the forms they are bound
to and the substituted template is then used in place of the macro.

In the following example, ~(incr! y)~ is effectively substituted by
~(set! y (+ y 1))~, so we have achieved what we wanted[fn:3]:

#+BEGIN_SRC scheme :exports both :wrap example
  (define y 10)
  (incr! y)
  y
#+END_SRC

#+RESULTS:
#+begin_example
11
#+end_example

As a side note, we see from the discussion that ~set!~ is another
keyword (like ~if~, it cannot be a procedure for the same reasons why
our attempt to write ~incr!~ as a procedure doesn't work).

** TODO A tracing ~let~

** TODO Accessing vector locations through variables

* TODO Syntax objects

** TODO Identifiers

** TODO Deconstructing syntax objects

** TODO Constructing syntax objects

* TODO Syntax-case macros

** TODO A fluid ~let~

** TODO Macro-generating macros

* TODO Breaking hygiene

** TODO A pitfall

* TODO Phasing

* TODO Extensions

** TODO Syntax parameters

** TODO Identifier properties

* TODO Examples

** TODO Implementing a DSL

* Footnotes
[fn:4]While Scheme does not forbid mutation (like ML but unlike
Haskell), the pitfalls of impure code are well-understood.  Therefore,
the names of Scheme procedures and syntax that modifies locations in
the store (the Scheme model of the computer's memory) end with a ~!~
by convention.

[fn:3]When interactively testing our procedures and syntax (keywords),
one has to be careful that we have given both the procedure and the
keyword the same name.  Evaluating one of the definitions will
overwrite the meaning of the other one.

[fn:2]More precicely: as a variable holding a procedure value.

[fn:1]This may change when the R7RS-large standardization effort is
finished.  Both, R6RS and R7RS-small, are successors (and extensions)
to R5RS (1998), but R7RS-small was never meant to be seen in isolation
as a successor to R6RS.  Time will tell whether the R7RS large
language will be able to replace R6RS when it is finally done.  It is
planned to include the R6RS macro facility in R7RS-large.
