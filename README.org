#+TITLE: Extending a Language --- Writing Powerful Macros in Scheme
#+AUTHOR: Marc Nieper-Wi√ükirchen
#+EMAIL: marc@nieper-wisskirchen.de

#+PROPERTY: header-args:scheme :session *session*

* Preface

This document is an introduction to writing powerful macros in Scheme.
It was initially written on the occasion of a tutorial I give at the
[[https://bobkonf.de/2023/en/][BOB2023 Konferenz]] in Berlin on 17 March 2023.

The macro facility, especially its built-in /hygiene/, is one of the
fundamental pillars of the Scheme programming language.  While more
complicated than the simple token-replacing macros of other languages
like C, Scheme macros can be written in a way that make them robust
and so that the abstractions they offer seamless blend into the
language and cannot be distinguished from syntactic forms built into
the language.  It is often felt that this expressiveness makes writing
Scheme macros more complicated (even something of a black art) than
writing C or Common Lisp macros, for example.  One goal of this
tutorial is to convince the audience otherwise.

While the Scheme macro facility has always been avant-garde (and this
is one of the reasons why Scheme was chosen as the implementation
language for this tutorial), a lot of what is said here also applies
to languages that provide corresponding features.  It is also a appeal
to language designers that languages should include a macro facility
as Scheme does, as this allows for small language cores and enables
the user to provide their own syntactic abstractions.

Another reason why the Scheme language is used in this tutorial is
that it has an exceptionally clear semantics, is a compact language,
and is easy to learn.

The document can both be read as is or used interactively in an Emacs
session.  In the following section, a possible setup is described.

* Prerequisites

** Chez Scheme

We need a Scheme implementation.  This tutorial assumes [[https://cisco.github.io/ChezScheme/][Chez Scheme]],
which is one of the most mature, standard-compliant Scheme
implementations.  You can get Chez Scheme from its homepage.  On
Debian-based GNU/Linux system like Ubuntu, it is prepackaged.

** Emacs

We will use [[https://www.gnu.org/software/emacs/][GNU Emacs]] as our development environment, which has great
tooling for Scheme.  The typical GNU/Linux system ships with it.

For GNU Emacs < 28, enable the [[https://elpa.nongnu.org/][NonGNU Emacs Lisp Package Archive]] in
your [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Init-File.html][init file]] or [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Easy-Customization.html][customize]] the variable ~package-archives~.

** Org

[[https://orgmode.org/][Org Mode]] is a GNU Emacs major mode that allows to document, edit and
execute source code.

The current versions of Org packaged with Emacs hide Scheme evaluation
errors.  This is fixed in the version in Org's git repository, for
which Org [[https://orgmode.org/org.html#Installation][provides installation instructions]].

Familiarize yourself with how one works with [[https://orgmode.org/org.html#Working-with-Source-Code][source code in an Org
document]], especially how to [[https://orgmode.org/org.html#Editing-Source-Code][edit]] and [[https://orgmode.org/org.html#Evaluating-Code-Blocks][execute code]].

** Geiser

[[https://www.nongnu.org/geiser/][Geiser]] is a GNU Emacs package that allows to runs Scheme processes in
GNU Emacs, and which is used by Org's Babel.  To install it, it is
enough to install the package [[https://gitlab.com/emacs-geiser/chez/-/blob/master/geiser-chez.el][geiser-chez]] using GNU Emacs' [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Package-Menu.html][package
menu]].  We need the most recent version.

** Paredit

[[https://paredit.org/][Paredit]], a tool for parenthetical editing in Emacs makes working with
Scheme code a lot more pleasant.  Like Geiser, it can be installed
through GNU Emacs' package manager.

** Initialization

After the GNU Emacs packages have been installed, we want to customize
them for our needs.  The following should go into your init file
unless you want to execute the following code every time you start GNU
Emacs.

#+BEGIN_SRC emacs-lisp :results none
  (require 'compile)
  (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code" t)
  (add-hook 'scheme-mode-hook #'enable-paredit-mode)
  (show-paren-mode t)
  (setq auto-mode-alist (cons '("\\.ss" . scheme-mode) auto-mode-alist))
  (setq auto-mode-alist (cons '("\\.sls" . scheme-mode) auto-mode-alist))
  (setq auto-mode-alist (cons '("\\.sps" . scheme-mode) auto-mode-alist))
  (add-to-list 'compilation-error-regexp-alist
               '("^\\(Exception\\|Warning\\).*: .* \\(line \\([0-9]+\\), char \\([0-9]+\\) of \\(.*\\)\\)" 5 3 4 nil 2))
  (setq geiser-default-implementation 'chez)
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((scheme . t)))
  (setq org-confirm-babel-evaluate nil)
#+END_SRC

* The Scheme programming language

Scheme is programming language of the Lisp family.  Its defining
properties are its uniform parenthesized syntax (inherited from Lisp),
first-class procedures and continuations, lexical scoping, dynamic
typing, proper tail calls and hygienic macros.  It is primarly a
functional programming language but allows many other programming
paradigms.

The Scheme programming language was developed in the 1970s by Guy
L. Steele and Gerald Jay Sussman.  Since then it has been refined and
further developed through a series of de facto standards called the
Revised^{/n/} Report(s) on the Algorithmic Language Scheme (R/n/RS).
The two current standards are R6RS (2007) and R7RS-small (2013).
Despite the versioning and the timeline, R6RS is the more detailed,
more advanced and more modern standard[fn:1].

In this tutorial, we work with the macro facility of R6RS, which is
far more powerful than the one of R7RS-small, and also discuss some
proposed or implemented extensions.  Such extensions to the Scheme
programming language are often proposed, discussed and implemented
using the [[https://srfi.schemers.org/][Scheme Requests for Implementation]] process, where everyone
can submit a /SRFI/ extending the Scheme programming language.
Whenever we speak of the /Scheme/ language in this text, we default to
the R6RS dialect.

For practical programming, one needs, of course, an implementation.
Scheme is possibly the programming language with the highest number of
implementations.  The R6RS language has some very high-quality
implementations, including [[https://cisco.github.io/ChezScheme/][Chez Scheme]], [[https://www.gnu.org/software/guile/][GNU Guile]], [[https://scheme.fail/][Loko Scheme]], and [[https://racket-lang.org/][Racket]],
so for any application area, there will be a suitable Scheme system.

* Some simple macros

Let us call a /combination/ an expression in Scheme of the form

#+BEGIN_SRC scheme :eval no
  (operator operand ...)
#+END_SRC

An example is given by the following expression evaluating to the answer of life:

#+BEGIN_SRC scheme :exports both :wrap example
  (* 21 2)
#+END_SRC

#+RESULTS:
#+begin_example
42
#+end_example

Such a combination is usually evaluated by evaluating the operator and
the operands in some unspecific order and by then calling the
procedure resulting from the operator evaluation with arguments
resulting from the operand evaluations.

Scheme, however, also possesses special forms, which do not follow
this evaluation strategy.  An example is given by the conditional ~if~.
#+BEGIN_SRC scheme :exports both :wrap example
  (if (number? 2)
      'ok
      (/ 1 0))
#+END_SRC

#+RESULTS:
#+begin_example
ok
#+end_example

If the conditional were a normal combination, the operands, and ~(/ 1
0)~ in particular, would have been evaluated first (and
unconditionally).  Scheme recognizes special forms through the
operator in first position, namely if it is a keyword (a special type
of identifier).  The Scheme macro facility allows the programmer to
define their own keywords.

** Incrementing a variable

Let us ignore for a moment that mutation is frowned upon in functional
programming and let us assume that we have to frequently increase the
value of variables in our program.  Given a variable ~x~, this is done
in Scheme through the following expression:
#+BEGIN_SRC scheme :eval no
  (set! x (+ x 1))
#+END_SRC
That the variable ~x~ is repeated in this expression is unpleasant
(and may be considered a violation of the DRY principle), so we want
an operator akin to C's pre/post-increment operator.  Unfortunately,
Scheme does not provide such an operator, but, fortunately, it doesn't
have to because we can build one ourself.

Our first attempt could be to write a procedure (the primary means of
abstraction in functional programming languages)[fn:4]:
#+BEGIN_SRC scheme :results silent
  (define incr!
    (lambda (x)
      (set! x (+ x 1))))
#+END_SRC

This attempt, however, is failed:
#+BEGIN_SRC scheme :exports both :wrap example
  (define x 1)
  (incr! x)
  x
#+END_SRC

#+RESULTS:
#+begin_example
1
#+end_example

The reason that it doesn't work --- the variable's value is still 1
and not 2 --- is that ~(incr! x)~ is a normal combination as
introduced earlier.  As the arguments are evaluated first and the
procedure is called with their values, in this example, ~incr!~ is
called with the argument ~1~.  This is then bound to a new variable
~x~ locally to ~incr!~.  It is this variable, which is increased by 1
and not the top-level variable.

The solution is, of course, to define ~incr!~ not as a procedure[fn:2]
but as a keyword.  In the Scheme programming language, the
~define-syntax~ keyword can be used for it:

#+BEGIN_SRC scheme :exports :results silent
  (define-syntax incr!
    (syntax-rules ()
      ((incr! x)
       (set! x (+ x 1)))))
#+END_SRC

This definition says that ~incr!~ is defined to be a new keyword,
implemented as a macro.  The ~syntax-rules~ line shall be viewed as
boilerplate for the moment (and we will come back to it later).
Important are the next two lines.  The form ~(incr! x)~ is a pattern
saying that the macro matches against a use of the form ~(keyword
form)~ (where ~keyword~ is necessarily ~incr!~).  When the macro is
used, the pattern variable ~x~ is bound to the ~form~.  The form
~(set! x (+ x 1))~ is a template.  When the macro is used, the pattern
variables in the template are replaced with the forms they are bound
to and the substituted template is then used in place of the macro.

In the following example, ~(incr! y)~ is effectively substituted by
~(set! y (+ y 1))~, so we have achieved what we wanted[fn:3]:

#+BEGIN_SRC scheme :exports both :wrap example
  (define y 10)
  (incr! y)
  y
#+END_SRC

#+RESULTS:
#+begin_example
11
#+end_example

As a side note, we see from the discussion that ~set!~ is another
keyword (like ~if~, it cannot be a procedure for the same reasons why
our attempt to write ~incr!~ as a procedure doesn't work).

As any other identifier in Scheme, the identifier ~set!~ can also be
rebound as in the following example:

#+BEGIN_SRC scheme :exports both :wrap example
  (let ([set! (lambda (x y) (+ x y))])
    (define x 1)
    (set! x 2))
#+END_SRC

#+RESULTS:
#+begin_example
3
#+end_example

In the body of the ~let~ form, ~set!~ has lost its usual meaning and
is bound to a procedure adding its two arguments.  It is most
interesting to see what happens when we use our ~incr!~ macro, which
refers to ~set!~, in the body of the ~let~ form:

#+BEGIN_SRC scheme :exports both :wrap example
  (let ([set! (lambda (x y) (/ 1 0))])
    (define x 1)
    (incr! x)
    x)
#+END_SRC

#+RESULTS:
#+begin_example
2
#+end_example

This example yields the correct result ~2~, although calling ~set!~
within the ~let~ body would raise an exception.  The reason for this
is the already mentioned hygiene of Scheme macros.  The identifier
~set!~ in the output of the ~incr!~ macro didn't occur in its input
but came from the macro definition.  Scheme macro hygiene now ensures
that it still refers to the lexical binding it had where it occured in
the program source.  Note that the C preprocessor --- as an example
for a very simple, if not primitive macro facility --- wouldn't have
ensured it.  Whether a C macro works correctly or not often depends on
the lexical environment of the macro use site.

We say that hygienic Scheme macros are referentially transparent.
This is already known from procedures in functional programming
languages and lexical scoping:

#+BEGIN_SRC scheme :results scalar :exports both :wrap example
  (define f
    (let ([x 1])
      (lambda () x)))

  (list (f)
        (let ([x 2])
          (f)))
#+END_SRC

#+RESULTS:
#+begin_example
(1 1)
#+end_example

Wherever the procedure ~f~ is called, it always evaluates to ~1~.

We finish this subsection with another example of hygiene:

#+BEGIN_SRC scheme :exports both :wrap example
  (let ([set! 2])
    (incr! set!)
    set!)
#+END_SRC

#+RESULTS:
#+begin_example
3
#+end_example

The result, which is the increment of the original value of the
variable ~set!~ by one, can again be explained by hygiene and by
distinguishing the identifier ~set!~ that appears in the macro use and
the same-named identifier ~set!~ appearing in the macro source.
Without distinguishing both, the macro use ~(incr! set!)~ is
transcribed to ~(set! set! (+ set! 1))~.  In this transcription, the
first ~set!~ originates from the macro transformer and thus still
refers to the lexical binding it had at that place.  The other two
occurrences of ~set!~ are copies from the macro input and thus refer
to the lexical binding of ~set!~ as a let-bound variable.

*** TODO Demonstrate macro that expands into itself.

** TODO A tracing ~let~

Simple loops are often written using the named ~let~ form as in the following example:
#+BEGIN_SRC scheme :results silent
  (define fact
    (lambda (n)
      (let f ([n n] [a 1])
        (if (zero? n)
            a
            (f (- n 1) (* a n))))))
#+END_SRC

In order to facilitate debugging, let us define a version of the named
~let~ form that prints the arguments with which the loop recursion is
entered and with which it is exited[fn:5].  As ~let~ is a special
form, this has to be a special form as well, so let us write our second macro:

#+BEGIN_SRC scheme :results silent
  ;; A form of a named let that prints information about each recursive
  ;; call.
  (define-syntax trace-let
    (syntax-rules ()
      [(trace-let name ([var expr] ...) body1 ... body2)
       (let f ([depth 0] [var expr] ...)
         (define name
           (lambda (var ...)
             (f (+ depth 1) var ...)))
         (indent depth)
         (display "(")
         (display 'name)
         (begin
           (display " ")
           (display var))
         ...
         (display ")")
         (newline)
         (call-with-values
             (lambda ()
               body1 ... body2)
           (lambda val*
             (indent depth)
             (fold-left
              (lambda (sep val)
                (display sep)
                (display val)
                " ")
              "" val*)
             (newline)
             (apply values val*))))]))

  ;; Helper procedure referenced by the macro output of the macro above.
  (define indent
    (let ([pattern "| "])
      (lambda (depth)
        (do ([i 0 (+ i 1)])
            ((> i depth))
          (display (string-ref pattern (mod i 2)))))))
#+END_SRC

In this macro, the pattern is given by ~(trace-let name ([var expr]
...) body1 ... body2)~, while the template makes up the bulk of the
macro.  Already in the pattern, we see a new syntax, the ellipsis
~...~.  It means that the subpattern preceding it may appear repeated
zero or more times in the input.  When such a subpattern is matched,
the contained pattern variables represent lists of forms.

In the template, the ellipsis means to repeat the preceding
subtemplate as many times as the pattern variables contained in it
represent forms.  For this to work, every such subtemplate has to
contain at least one pattern variable, obviously, and all pattern
variables contained in it have to represent lists of forms of the same
length.

Note the occurrence of ~begin~ in the macro.  Normally, in a procedure
body, ~(begin expression ...)~ is equivalent to the list of
~expressions~, here, however, we have to use it.  The reason is that
following ellipsis refers the immediately preceding subtemplate, so it
is crucial that the two display commands (which we both want to
repeated once per variable) appear in a single form.

When we run the following test, we see the given result printed.

#+BEGIN_SRC scheme :exports both :results output :wrap example
  (define fact
    (lambda (n)
      (trace-let f ([n n])
        (if (zero? n)
            1
            (* (f (- n 1)) n)))))
  (fact 3)
#+END_SRC

#+RESULTS:
#+begin_example
|(f 3)
| (f 2)
| |(f 1)
| | (f 0)
| | 1
| |1
| 2
|6
#+end_example

We can demonstrate another facet of hygiene with this particular
macro.  In the macro template, which is part of the macro's source,
the identifier ~f~ is introduced and is bound by ~let~ appearing next
to in the source.  In the particular use of the macro above, the
pattern variable ~name~ represents another identifier name ~f~, namely
the identifier with that name that appears in the macro use.  Although
~f~ coming from the macro use is bound in the macro output within the
scope of the binding of ~f~ coming from the macro text, it does not
shadow the other ~f~ as this would be a violation of hygiene.
Instead, the identifier ~f~ coming from the macro text is renamed by
the Scheme macro expander, at least conceptually (as it isn't inserted
as a free identifier, the precise name obviously doesn't matter).

The ellipsis can also be used to turn our ~incr!~ macro into one that
accepts more than one variable to increment:

#+BEGIN_SRC scheme :results silent
  (define-syntax incr!
    (syntax-rules ()
      ((incr! x ...)
       (begin
         (set! x (+ x 1))
         ...))))
#+END_SRC

Let us briefly test our new extended macro:

#+BEGIN_SRC scheme :results scalar :exports both :wrap example
  (define x 10)
  (define y 20)
  (incr! x y)
  (list x y)
#+END_SRC

#+RESULTS:
#+begin_example
(11 21)
#+end_example

The role of ~begin~ in the macro definition of the extended ~incr!~
differs from the role in our previous use of ~begin~.  Here it is used
to solve the problem that the template that prescribes the macro
output has to be a single form.

One can also write the multi-variable ~incr!~ macro without the
ellipsis by letting the macro expand into itself.  This is not
necessarily how one would do it, but here it serves as a demonstration
for further macro techniques:

#+BEGIN_SRC scheme :results silent
  (define-syntax incr!
    (syntax-rules ()
      ((incr!)
       (values))
      ((incr! x . x*)
       (begin
         (set! x (+ x 1))
         (incr! . x*)))))
#+END_SRC

First of all, this is our first macro with two transcription /rules/,
where each rule consists of a pattern and of a template.  The pattern
of the first rule is ~(incr!)~, the pattern of the second rule is
~(incr! x . x*)~.  Scheme's macro expander tries to match the macro
input against the patterns in the order in which the patterns appear
in the ~syntax-rules~ form.

The second new thing is a a pattern of the form ~(incr! x . x*)~,
which matches an (improper) list of at least two elements, the first
being the macro keyword and the second one being bound to the pattern
variable ~x~.  The rest arguments are bound as an (improper) list to
the pattern variable ~x*~.

Finally, this example demonstrates a recursive macro, that is a macro
that transforms the input into an instance of itself.  As long as the
output of a macro use involves a new macro use (possibly with the same
keyword), the Scheme expander continues with transcribing the macro.

Let us not forget to test the new version of the macro:

#+BEGIN_SRC scheme :results scalar :exports both :wrap example
  (define x 100)
  (define y 200)
  (incr! x y)
  (list x y)
#+END_SRC

#+RESULTS:
#+begin_example
(101 201)
#+end_example

** Accessing vector locations through variables

A /vector/ in Scheme is a collection of locations in the store that
can be linearly addressed.  A new vector can be allocated with the
~vector~ procedure:

#+BEGIN_SRC scheme :results scalar :exports both :wrap example
  (define v (vector 1 2 3))
  v
#+END_SRC

#+RESULTS:
#+begin_example
#(1 2 3)
#+end_example

Vector elements can be retrieved using ~vector-ref~ and mutated using ~vector-set!~:

#+BEGIN_SRC scheme :results scalar :exports both :wrap example
  (vector-ref v 2)
#+END_SRC

#+RESULTS:
#+begin_example
3
#+end_example

#+BEGIN_SRC scheme :results scalar :exports both :wrap example
  (vector-set! v 1 4)
  v
#+END_SRC

#+RESULTS:
#+begin_example
#(1 4 3)
#+end_example

Assume that we want to use our ~incr!~ macro to increase the value of
one vector element.  As ~incr!~ expects a variable as its argument, we
have make the locations associated to a vector accessible as if they
were backed up by a variable.  Another feature of the (R6RS) macro
system comes to our rescue:

#+BEGIN_SRC scheme :results scalar :exports both :wrap example
  (define-syntax v1
    (identifier-syntax
     [v1 (vector-ref v 1)]
     [(set! v1 expr) (vector-set! v 1 expr)]))
  (incr! v1)
  v
#+END_SRC

#+RESULTS:
#+begin_example
#(1 6 3)
#+end_example

This macro isn't written with ~syntax-rules~ but uses
~identifier-syntax~.  This is used to declare a keyword, ~v1~ in our
case, that is transcribed differently, depending on whether it appears
in the form ~v1~ or in the form ~(set! v1 expr)~ in the source code.

To access the zeroth or the second element of the vector ~v~, we could
define identifier macros ~v0~ and ~v2~ similar to ~v1~ but this would
mean mostly duplicating code and violating the DRY principle.  A
better approach is to use the Scheme macro system once more.  We
define a macro that, when used, defines a customized macro[fn:6]:

#+BEGIN_SRC scheme :results silent
  (define-syntax define-vector-reference
    (syntax-rules ()
      [(define-vector-reference var vec-expr idx-expr)
       (begin
         (define vec vec-expr)
         (define idx idx-expr)
         (define-syntax var
           (identifier-syntax
            [var (vector-ref vec idx)]
            [(set! var expr) (vector-set! vec idx expr)])))]))
#+END_SRC

We can now use this macro as follows:

#+BEGIN_SRC scheme :results scalar :exports both :wrap example
  (define-vector-reference initial-element v 0)
  (incr! initial-element)
  v
#+END_SRC

#+RESULTS:
#+begin_example
#(2 6 3)
#+end_example

Note that the arguments ~vec-expr~ and ~idx-expr~ can stand for
arbitrary expressions.  We evaluate these expressions once and store
their values in the variables ~vec~ and ~idx~ (which will be suitably
renamed by the macro expander so that they won't clash with user
defined identifiers with the same name).  If we didn't do this but
used ~vec-expr~ and ~idx-expr~ everywhere in place where ~vec~ and
~idx~ appeared in the defined macro, the vector and the index
expressions would be evaluated every time, the vector reference
variable would be accessed.

* TODO Syntax objects

The Scheme reports define hygiene and referential transparency for
macros as follows:

- If a macro transformer inserts a binding for an identifier (variable
  or keyword) not appearing in the macro use, the identifier is in
  effect rename throughout its scope to avoid conflicts with other
  identifiers.

- If a macro transformer inserts a free reference to an identifier,
  the reference refers to the binding that was visible where the
  transformer was specified, regardless of any local bindings that may
  surround the use of the macro.

The examples of the previous section make it hopefully a bit clear
what is meant by these two points.  Nevertheless, one may think that
there still must be some magic at work and that it will be impossible
to prove anything about these macros.  The purpose of this section is
to disassemble everything and to explain what is going on under the
hood.

** TODO Identifiers

The Lisp languages, and thus Scheme as well, are homoiconic
programming languages, which means that if the program's internal
representation is a datum of the language.  In first approximation,
the internal representation of a Scheme expression (as of a Scheme
program) is a Scheme datum value.  For example, the program
(expression)

#+BEGIN_SRC scheme :eval no
  (let ([x 1])
    (+ x 2))
#+END_SRC

is represented by a list whose first element is the symbol ~let~,
whose second element is a list of a list with two elements and whose
third element is a list of the three data ~+~, ~x~, and ~2~.

Due to existence of hygienic macros we have to amend this traditional
picture.  Consider the following example.

#+BEGIN_SRC scheme :eval no
  (let ([set! 10])
    (incr! set!)
    set!)
#+END_SRC

To evaluate the ~let~ expression, the macro use of ~incr!~ has to be
expanded first.  After the expansion, the expression would look like

#+BEGIN_SRC scheme :eval no
  (let ([set! 10])
    (set! set! (+ set! 1))
    set!)
#+END_SRC

if Scheme expressions were represented by Scheme datum values and
within, identifiers were represented by symbols.  It is obvious that
this cannot be how the Scheme expander works because there would be no
way to tell which copy of the symbol ~set!~ refers to which binding.
The point is that identifiers cannot be represented by symbols, which
only have a symbolic name.  Instead, to an /identifier/ both a
symbolic name and a lexical context are associated.  When the binding
of an identifier is looked up, it is looked up in the lexical context
associated with it.

In Scheme, symbols are first-class values.  The can be created using
the syntax ~(quote name)~, which can be abbreviated to ~'name~:

#+BEGIN_SRC scheme :results scalar :exports both :wrap example
  'red
#+END_SRC

#+RESULTS:
#+begin_example
red
#+end_example

The same is true for identifiers.  They are created just like symbols
but use the syntax ~(syntax identifier)~, which can be abbreviated to
~#'identifier~, instead:

#+BEGIN_SRC scheme :results scalar :exports both :wrap example
  #'x
#+END_SRC

#+RESULTS:
#+begin_example
#<syntax x>
#+end_example

(The format of the output, ~#<syntax x>~, is implementation-specific,
because identifiers are not Scheme datum values and thus have no
standardized or faithful written representation.)

Evaluating of the form ~(syntax x)~ (or ~#'x~) means the following for
the Scheme system: construct and return an identifier with the
symbolic name ~x~ and with the lexical context at the place of the ~x~
appearing in the ~syntax~ form.  We have to be aware of that the term
~identifier~ can be used in two (slightly) different contexts: When we
refer to ~set!~ as an identifier in the example above, we speak about
a token being part of the code.  When we refer to the expression ~#'x~
evaluating to an identifier, we speak about a value of the language.
The expression ~#'x~ contains an identifier in the first sense
(speaking about the language) and evaluates to an identifier (as a
value of the language).

The procedure ~syntax->datum~ can be used to convert an identifier to
a symbol, namely its underlying symbolic name:

#+BEGIN_SRC scheme :results scalar :exports both :wrap example
  (syntax->datum #'x)
#+END_SRC

#+RESULTS:
#+begin_example
x
#+end_example

There are no standard procedures that allow us to look up the binding
of an identifier, but we can compare identifiers.  Scheme defines two
equivalence relations, realized by the predicates ~bound-identifier=?~
and ~free-identifier=?~.  Two identifiers are "~bound-identifier=?~"
if they are interchangeable when they appear bound in the output of a
macro.  Two identifiers are "~free-identifier=?~" if they are
interchangeable when they appear free in the output of a macro.
Neither equivalence implies the other.  It will become clearer in the
course of this tutorial what this means, but some experiments will
already give some understanding:

#+BEGIN_SRC scheme :results scalar :exports both :wrap example
  (list (bound-identifier=? #'x #'x) (bound-identifier=? #'x #'y))
#+END_SRC

#+RESULTS:
#+begin_example
(#t #f)
#+end_example

The two identifiers to which the two evaluations of ~#'x~ in the first
argument to ~list~ evaluate are therefore "~bound-identifier=?~" while
the differently named identifiers ~#'x~ and ~#'y~ (more precisely: the
identifiers returned by these expressions) are not.  It is tempting to
say that the two (or three) instances of ~#'x~ evaluate to the /same/
identifier, but for this to make sense, some equivalence relation
would have had to be fixed earlier.

Let us now consider two simple examples for ~free-identifier=?~:

#+BEGIN_SRC scheme :results scalar :exports both :wrap example
  (let ([x 1])
    (free-identifier=? #'x #'x))
#+END_SRC

#+RESULTS:
#+begin_example
#t
#+end_example

If the identifiers to both instances of ~#'x~ evaluate were inserted
in the code as free identifiers they both would refer to the variable
binding of the identifier ~x~ introduced by ~let~.

The second example is a bit more interesting:

#+BEGIN_SRC scheme :results scalar :exports both :wrap example
  (let ([x 1]
        [y 1])
    (free-identifier=? #'x #'y))
#+END_SRC

#+RESULTS:
#+begin_example
#f
#+end_example

The answer is ~#f~ (for false) because although the values of the two
variables ~x~ and ~y~ are both initialized to ~1~ they are bound to
different locations in the store (which can be exhibited by mutating
one of the two variables.

So far, in all examples ~bound-identifier=?~ seems to give the same
result as ~free-identifier=?~.  That this is not true is shown in the
next example.

#+BEGIN_SRC scheme :results scalar :exports both :wrap example
  (let ([x 1])
    (define outer-x #'x)
    (let ([x 2])
      (define inner-x #'x)
      (list (bound-identifier=? outer-x inner-x)
            (free-identifier=? outer-x inner-x))))
#+END_SRC

#+RESULTS:
#+begin_example
(#t #f)
#+end_example

Inserting ~inner-x~ as a free identifier would not be equivalent to
inserting ~outer-x~ because the former would refer to the binding of
the variable with value ~2~ and the latter to the binding of the
variable with value ~1~.  Thus identifiers that are
"~bound-identifier=?~" are not necessarily "~free-identifier~".  We
hope that the connection of ~free-identifier=?~ to the second hygiene
condition, the one about inserting free references to an identifier,
is apparent.

Again so far, it seems that identifiers are "~bound-identifier=?~" if
and only if they have the same symbolic name.  One implication is
correct, namely that identifiers that are interchangeable as bound identifiers
must have the same symbolic name, but the other implication is not.  To show this, we have to employ a macro:

#+BEGIN_SRC scheme :results scalar :exports both :wrap example
  (let ([x 1])
    (let-syntax
        ([outer-x (identifier-syntax #'x)])
      (define inner-x #'x)
      (list (bound-identifier=? outer-x inner-x)
            (free-identifier=? outer-x inner-x))))
#+END_SRC

#+RESULTS:
#+begin_example
(#f #t)
#+end_example

Two remarks about the example code are in order before we discuss the
result.  The binding form ~let-syntax~ is to ~let~ as ~define-syntax~
is to ~define~; in other words, it allows us to locally bind keywords
to macro (transformers).  Furthermore, we employ a short form of
~identifier-syntax~ here, which defines no ~set!~ semantics but just
replaces an occurrence of the keyword ~outer-x~ with ~#'x~.

Both the identifier ~x~ in the definition of the macro ~outer-x~ and
the identifier ~x~ in the definition of the variable ~inner-x~ refer
to the binding of ~x~ introduced by the outer ~let~, which explains
that the values of ~outer-x~ and ~inner-x~ are "~free-identifier=?~".
But they are not "~bound-identifier=?~", so this example shows that
identifiers that "~free-identifier=?~" need not necessarily be
"~bound-identifier=?~".

The reason why they cannot be "~bound-identifier=?~" is that the first
hygiene condition about inserting bindings for an identifier would be
violated otherwise.  Consider the following example:

#+BEGIN_SRC scheme :results scalar :exports both :wrap example
  (let-syntax
      ([add1
        (syntax-rules ()
          [(add1 y)
           (let ([x 1])
             (+ x y))])])
    (let ([x 2])
      (add1 x)))
#+END_SRC

#+RESULTS:
#+begin_example
3
#+end_example

The identifier ~x~ appearing in the macro template is inserted as a
bound identifier in the macro output and thus is in effect renamed to
avoid conflict with the identifier ~x~ appearing in the macro use.
Renaming means that the two identifiers named ~x~ cannot be
"~bound-identifier=?~" because they would otherwise be interchangeable
as bound identifiers.

Scheme implements this hygiene condition by assigning to identifiers
besides their symbolic name and their lexical context another
property, namely their historic context (or just history)[fn:7].  The
history of an identifier is the information when the identifier was
first introduced in the program.  All identifiers in the program
source have the same history --- they were already there when the
program was started.  An identifier introduced by a macro
transformation (as part of its output) has a different history than
identifiers that were already present in the program source.
Identifiers introduced by different macro transformations have
different histories and all identifiers introduced by the same macro
transformation have the same history.

Let us take another view at this example:

#+BEGIN_SRC scheme :results scalar :exports both :wrap example
  (let ([x 1])
    (let-syntax
        ([outer-x (identifier-syntax #'x)])
      (define inner-x #'x)
      (list (bound-identifier=? outer-x inner-x)
            (free-identifier=? outer-x inner-x))))
#+END_SRC

The identifier ~x~ appears three times in the source.  All three
identifiers have the same history.  When the macro ~outer-x~ is
expanded, the identifier ~x~ is introduced in the macro output (as
part of the expression ~#'x~) and this particular identifier was not
part of the macro input, so the introduced identifier ~x~ has a
different history than the identifier to which ~inner-x~ is bound.

We are now in a situation to give alternative definitions for
~bound-identifier=?~ and ~free-identifier=?~: Two identifiers are
"~bound-identifier=?~" if they have the same symbolic name and the
same history.  Two identifiers are "~free-identifier=?~" if they refer
to the same binding in their respective lexical contexts.  (An unbound
identifier is, by definition, "~free-identifier=?~" to another
identifier if the other identifier is also unbound and has the same
symbolic name.)

Scheme also allows to fudge identifiers.  The procedure
~datum->syntax~ can turn a symbol into an identifier with that
symbolic name.  For that, the user has to provide a lexical context
and a history.  This is done by giving a "template" identifier from
which the context is taken.

#+BEGIN_SRC scheme :results scalar :exports both :wrap example
  (let ([x 1])
    (define outer-x #'x)
    (let ([x 2])
      (define outer (datum->syntax outer-x 'x))
      (list (bound-identifier=? outer-x outer)
            (free-identifier=? outer-x outer))))
#+END_SRC

#+RESULTS:
#+begin_example
(#t #t)
#+end_example

In this example, the identifier ~outer~ is an identifier with the
symbolic name ~x~ and with the context as if it was introduced where
~x~ appears in the definition of ~outer-x~.

In the following example, the fudged identifier with the symbolic name
~y~ has the same history as the identifier ~x~ appearing the macro use
of ~as-y~, and thus the same history as the identifier ~y~ appearing
in the call to ~bound-identifier=?~.

#+BEGIN_SRC scheme :results scalar :exports both :wrap example
  (let-syntax
      ([as-y
        (syntax-rules ()
          [(as-y x) (datum->syntax #'x 'y)])])
    (bound-identifier=? #'y (as-y x)))
#+END_SRC

#+RESULTS:
#+begin_example
#t
#+end_example

** TODO Deconstructing syntax objects

*** TODO Describe syntax objects.  Tell about wrapped and unwrapped ones.

** TODO Constructing syntax objects

* TODO Syntax-case macros

** TODO A fluid ~let~

** TODO Macro-generating macros

* TODO Breaking hygiene

** TODO A pitfall

* TODO Phasing

* TODO Extensions

** TODO Syntax parameters

** TODO Identifier properties

* TODO Examples

** TODO Implementing a DSL

* Footnotes

[fn:7]The term "history" of an identifier is not an established one
but was invented for this presentation.

[fn:6]Note that this cannot be done with C preprocessor macros.

[fn:5]Such a form is predefined in Chez Scheme, but is not part of the
Scheme standard.  In fact, Chez Scheme's version properly handles tail
calls, which our simple version doesn't.

[fn:4]While Scheme does not forbid mutation (like ML but unlike
Haskell), the pitfalls of impure code are well-understood.  Therefore,
the names of Scheme procedures and syntax that modifies locations in
the store (the Scheme model of the computer's memory) end with a ~!~
by convention.

[fn:3]When interactively testing our procedures and syntax (keywords),
one has to be careful that we have given both the procedure and the
keyword the same name.  Evaluating one of the definitions will
overwrite the meaning of the other one.

[fn:2]More precicely: as a variable holding a procedure value.

[fn:1]This may change when the R7RS-large standardization effort is
finished.  Both, R6RS and R7RS-small, are successors (and extensions)
to R5RS (1998), but R7RS-small was never meant to be seen in isolation
as a successor to R6RS.  Time will tell whether the R7RS large
language will be able to replace R6RS when it is finally done.  It is
planned to include the R6RS macro facility in R7RS-large.

#  LocalWords:  preprocessor expander homoiconic
