#+TITLE: Extending a Language --- Writing Powerful Macros in Scheme
#+AUTHOR: Marc Nieper-Wi√ükirchen
#+EMAIL: marc@nieper-wisskirchen.de

#+PROPERTY: header-args:scheme :session *session*

* Preface

This document is an introduction to writing powerful macros in Scheme.
It was initially written on the occasion of a tutorial I give at the
[[https://bobkonf.de/2023/en/][BOB2023 Konferenz]] in Berlin on 17 March 2023.

The macro facility, especially its built-in /hygiene/, is one of the
fundamental pillars of the Scheme programming language.  While more
complicated than the simple token-replacing macros of other languages
like C, Scheme macros can be written in a way that make them robust
and so that the abstractions they offer seamless blend into the
language and cannot be distinguished from syntactic forms built into
the language.  It is often felt that this expressiveness makes writing
Scheme macros more complicated (even something of a black art) than
writing C or Common Lisp macros, for example.  One goal of this
tutorial is to convince the audience otherwise.

While the Scheme macro facility has always been avant-garde (and this
is one of the reasons why Scheme was chosen as the implementation
language for this tutorial), a lot of what is said here also applies
to languages that provide corresponding features.  It is also a appeal
to language designers that languages should include a macro facility
as Scheme does, as this allows for small language cores and enables
the user to provide their own syntactic abstractions.

The document can both be read as is or used interactively in an Emacs
session.  In the following section, a possible setup is described.

* Prerequisites

** Chez Scheme

We need a Scheme implementation.  This tutorial assumes [[https://cisco.github.io/ChezScheme/][Chez Scheme]],
which is one of the most mature, standard-compliant Scheme
implementations.  You can get Chez Scheme from its homepage.  On
Debian-based GNU/Linux system like Ubuntu, it is prepackaged.

** Emacs

We will use [[https://www.gnu.org/software/emacs/][GNU Emacs]] as our development environment, which has great
tooling for Scheme.  The typical GNU/Linux system ships with it.

For GNU Emacs < 28, enable the [[https://elpa.nongnu.org/][NonGNU Emacs Lisp Package Archive]] in
your [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Init-File.html][init file]] or [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Easy-Customization.html][customize]] the variable ~package-archives~.

** Org

[[https://orgmode.org/][Org Mode]] is a GNU Emacs major mode that allows to document, edit and
execute source code.

The current versions of Org packaged with Emacs hide Scheme evaluation
errors.  This is fixed in the version in Org's git repository, for
which Org [[https://orgmode.org/org.html#Installation][provides installation instructions]].

Familiarize yourself with how one works with [[https://orgmode.org/org.html#Working-with-Source-Code][source code in an Org
document]], especially how to [[https://orgmode.org/org.html#Editing-Source-Code][edit]] and [[https://orgmode.org/org.html#Evaluating-Code-Blocks][execute code]].

** Geiser

[[https://www.nongnu.org/geiser/][Geiser]] is a GNU Emacs package that allows to runs Scheme processes in
GNU Emacs, and which is used by Org's Babel.  To install it, it is
enough to install the package [[https://gitlab.com/emacs-geiser/chez/-/blob/master/geiser-chez.el][geiser-chez]] using GNU Emacs' [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Package-Menu.html][package
menu]].  We need the most recent version.

** Paredit

[[https://paredit.org/][Paredit]], a tool for parenthetical editing in Emacs makes working with
Scheme code a lot more pleasant.  Like Geiser, it can be installed
through GNU Emacs' package manager.

** Initialization

After the GNU Emacs packages have been installed, we want to customize
them for our needs.  The following should go into your init file
unless you want to execute the following code every time you start GNU
Emacs.

#+BEGIN_SRC emacs-lisp :results none
  (require 'compile)
  (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code" t)
  (add-hook 'scheme-mode-hook #'enable-paredit-mode)
  (show-paren-mode t)
  (setq auto-mode-alist (cons '("\\.ss" . scheme-mode) auto-mode-alist))
  (setq auto-mode-alist (cons '("\\.sls" . scheme-mode) auto-mode-alist))
  (setq auto-mode-alist (cons '("\\.sps" . scheme-mode) auto-mode-alist))
  (add-to-list 'compilation-error-regexp-alist
               '("^\\(Exception\\|Warning\\).*: .* \\(line \\([0-9]+\\), char \\([0-9]+\\) of \\(.*\\)\\)" 5 3 4 nil 2))
  (setq geiser-default-implementation 'chez)
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((scheme . t)))
  (setq org-confirm-babel-evaluate nil)
#+END_SRC

* The Scheme programming language

Scheme is programming language of the Lisp family.  Its defining
properties are its uniform parenthesized syntax (inherited from Lisp),
first-class procedures and continuations, lexical scoping, dynamic
typing, proper tail calls and hygienic macros.  It is primarly a
functional programming language but allows many other programming
paradigms.

The Scheme programming language was developed in the 1970s by Guy
L. Steele and Gerald Jay Sussman.  Since then it has been refined and
further developed through a series of de facto standards called the
Revised^{/n/} Report(s) on the Algorithmic Language Scheme (R/n/RS).
The two current standards are R6RS (2007) and R7RS-small (2013).
Despite the versioning and the timeline, R6RS is the more detailed,
more advanced and more modern standard[fn:1].

In this tutorial, we work with the macro facility of R6RS, which is
far more powerful than the one of R7RS-small, and also discuss some
proposed or implemented extensions.  Such extensions to the Scheme
programming language are often proposed, discussed and implemented
using the [[https://srfi.schemers.org/][Scheme Requests for Implementation]] process, where everyone
can submit a /SRFI/ extending the Scheme programming language.

For practical programming, one needs, of course, an implementation.
Scheme is possibly the programming language with the highest number of
implementations.  The R6RS language has some very high-quality
implementations, including [[https://cisco.github.io/ChezScheme/][Chez Scheme]], [[https://www.gnu.org/software/guile/][GNU Guile]], [[https://scheme.fail/][Loko Scheme]], and [[https://racket-lang.org/][Racket]],
so for any application area, there will be a suitable Scheme system.

* TODO Some simple macros

** TODO Incrementing a variable

#+BEGIN_SRC scheme :exports :results silent
  (define-syntax incr!
    (syntax-rules ()
      ((incr! x)
       (set! x (+ x 1)))))
#+END_SRC

#+BEGIN_SRC scheme :exports both :wrap example
  (define x 10)
  (incr! x)
  x
#+END_SRC

#+RESULTS:
#+begin_example
11
#+end_example

** TODO A tracing ~let~

** TODO Accessing vector locations through variables

* TODO Syntax objects

** TODO Identifiers

** TODO Deconstructing syntax objects

** TODO Constructing syntax objects

* TODO Syntax-case macros

** TODO A fluid ~let~

** TODO Macro-generating macros

* TODO Breaking hygiene

** TODO A pitfall

* TODO Phasing

* TODO Extensions

** TODO Syntax parameters

** TODO Identifier properties

* TODO Examples

** TODO Implementing a DSL

* Footnotes

[fn:1] This may change when the R7RS-large standardization effort is
finished.  Both, R6RS and R7RS-small, are successors (and extensions)
to R5RS (1998), but R7RS-small was never meant to be seen in isolation
as a successor to R6RS.  Time will tell whether the R7RS large
language will be able to replace R6RS when it is finally done.  It is
planned to include the R6RS macro facility in R7RS-large.
