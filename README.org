#+TITLE: Extending a Language --- Writing Powerful Macros in Scheme
#+AUTHOR: Marc Nieper-Wi√ükirchen
#+EMAIL: marc@nieper-wisskirchen.de

#+PROPERTY: header-args:scheme :session *session*

* Preface

This document is an introduction to writing powerful macros in Scheme.
It was initially written on the occasion of a tutorial I give at the
[[https://bobkonf.de/2023/en/][BOB2023 Konferenz]] in Berlin on 17 March 2023.

The macro facility, especially its built-in /hygiene/, is one of the
fundamental pillars of the Scheme programming language.  While more
complicated than the simple token-replacing macros of other languages
like C, Scheme macros can be written in a way that make them robust
and so that the abstractions they offer seamless blend into the
language and cannot be distinguished from syntactic forms built into
the language.  It is often felt that this expressiveness makes writing
Scheme macros more complicated (even something of a black art) than
writing C or Common Lisp macros, for example.  One goal of this
tutorial is to convince the audience otherwise.

While the Scheme macro facility has always been avant-garde (and this
is one of the reasons why Scheme was chosen as the implementation
language for this tutorial), a lot of what is said here also applies
to languages that provide corresponding features.  It is also a appeal
to language designers that languages should include a macro facility
as Scheme does, as this allows for small language cores and enables
the user to provide their own syntactic abstractions.

Another reason why the Scheme language is used in this tutorial is
that it has an exceptionally clear semantics, is a compact language,
and is easy to learn.

The document can both be read as is or used interactively in an Emacs
session.  In the following section, a possible setup is described.

* Prerequisites

** Chez Scheme

We need a Scheme implementation.  This tutorial assumes [[https://cisco.github.io/ChezScheme/][Chez Scheme]],
which is one of the most mature, standard-compliant Scheme
implementations.  You can get Chez Scheme from its homepage.  On
Debian-based GNU/Linux system like Ubuntu, it is prepackaged.

** Emacs

We will use [[https://www.gnu.org/software/emacs/][GNU Emacs]] as our development environment, which has great
tooling for Scheme.  The typical GNU/Linux system ships with it.

For GNU Emacs < 28, enable the [[https://elpa.nongnu.org/][NonGNU Emacs Lisp Package Archive]] in
your [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Init-File.html][init file]] or [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Easy-Customization.html][customize]] the variable ~package-archives~.

** Org

[[https://orgmode.org/][Org Mode]] is a GNU Emacs major mode that allows to document, edit and
execute source code.

The current versions of Org packaged with Emacs hide Scheme evaluation
errors.  This is fixed in the version in Org's git repository, for
which Org [[https://orgmode.org/org.html#Installation][provides installation instructions]].

Familiarize yourself with how one works with [[https://orgmode.org/org.html#Working-with-Source-Code][source code in an Org
document]], especially how to [[https://orgmode.org/org.html#Editing-Source-Code][edit]] and [[https://orgmode.org/org.html#Evaluating-Code-Blocks][execute code]].

** Geiser

[[https://www.nongnu.org/geiser/][Geiser]] is a GNU Emacs package that allows to runs Scheme processes in
GNU Emacs, and which is used by Org's Babel.  To install it, it is
enough to install the package [[https://gitlab.com/emacs-geiser/chez/-/blob/master/geiser-chez.el][geiser-chez]] using GNU Emacs' [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Package-Menu.html][package
menu]].  We need the most recent version.

** Paredit

[[https://paredit.org/][Paredit]], a tool for parenthetical editing in Emacs makes working with
Scheme code a lot more pleasant.  Like Geiser, it can be installed
through GNU Emacs' package manager.

** Initialization

After the GNU Emacs packages have been installed, we want to customize
them for our needs.  The following should go into your init file
unless you want to execute the following code every time you start GNU
Emacs.

#+BEGIN_SRC emacs-lisp :results none
  (require 'compile)
  (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code" t)
  (add-hook 'scheme-mode-hook #'enable-paredit-mode)
  (show-paren-mode t)
  (setq auto-mode-alist (cons '("\\.ss" . scheme-mode) auto-mode-alist))
  (setq auto-mode-alist (cons '("\\.sls" . scheme-mode) auto-mode-alist))
  (setq auto-mode-alist (cons '("\\.sps" . scheme-mode) auto-mode-alist))
  (add-to-list 'compilation-error-regexp-alist
               '("^\\(Exception\\|Warning\\).*: .* \\(line \\([0-9]+\\), char \\([0-9]+\\) of \\(.*\\)\\)" 5 3 4 nil 2))
  (setq geiser-default-implementation 'chez)
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((scheme . t)))
  (setq org-confirm-babel-evaluate nil)
#+END_SRC

* The Scheme programming language

Scheme is programming language of the Lisp family.  Its defining
properties are its uniform parenthesized syntax (inherited from Lisp),
first-class procedures and continuations, lexical scoping, dynamic
typing, proper tail calls and hygienic macros.  It is primarly a
functional programming language but allows many other programming
paradigms.

The Scheme programming language was developed in the 1970s by Guy
L. Steele and Gerald Jay Sussman.  Since then it has been refined and
further developed through a series of de facto standards called the
Revised^{/n/} Report(s) on the Algorithmic Language Scheme (R/n/RS).
The two current standards are R6RS (2007) and R7RS-small (2013).
Despite the versioning and the timeline, R6RS is the more detailed,
more advanced and more modern standard[fn:1].

In this tutorial, we work with the macro facility of R6RS, which is
far more powerful than the one of R7RS-small, and also discuss some
proposed or implemented extensions.  Such extensions to the Scheme
programming language are often proposed, discussed and implemented
using the [[https://srfi.schemers.org/][Scheme Requests for Implementation]] process, where everyone
can submit a /SRFI/ extending the Scheme programming language.

For practical programming, one needs, of course, an implementation.
Scheme is possibly the programming language with the highest number of
implementations.  The R6RS language has some very high-quality
implementations, including [[https://cisco.github.io/ChezScheme/][Chez Scheme]], [[https://www.gnu.org/software/guile/][GNU Guile]], [[https://scheme.fail/][Loko Scheme]], and [[https://racket-lang.org/][Racket]],
so for any application area, there will be a suitable Scheme system.

* TODO Some simple macros

Let us call a /combination/ an expression in Scheme of the form

#+BEGIN_SRC scheme :eval no
  (operator operand ...)
#+END_SRC

An example is given by the following expression evaluating to the answer of life:

#+BEGIN_SRC scheme :exports both :wrap example
  (* 21 2)
#+END_SRC

#+RESULTS:
#+begin_example
42
#+end_example

Such a combination is usually evaluated by evaluating the operator and
the operands in some unspecific order and by then calling the
procedure resulting from the operator evaluation with arguments
resulting from the operand evaluations.

Scheme, however, also possesses special forms, which do not follow
this evaluation strategy.  An example is given by the conditional ~if~.
#+BEGIN_SRC scheme :exports both :wrap example
  (if (number? 2)
      'ok
      (/ 1 0))
#+END_SRC

#+RESULTS:
#+begin_example
ok
#+end_example

If the conditional were a normal combination, the operands, and ~(/ 1
0)~ in particular, would have been evaluated first (and
unconditionally).  Scheme recognizes special forms through the
operator in first position, namely if it is a keyword (a special type
of identifier).  The Scheme macro facility allows the programmer to
define their own keywords.

** Incrementing a variable

Let us ignore for a moment that mutation is frowned upon in functional
programming and let us assume that we have to frequently increase the
value of variables in our program.  Given a variable ~x~, this is done
in Scheme through the following expression:
#+BEGIN_SRC scheme :eval no
  (set! x (+ x 1))
#+END_SRC
That the variable ~x~ is repeated in this expression is unpleasant
(and may be considered a violation of the DRY principle), so we want
an operator akin to C's pre/post-increment operator.  Unfortunately,
Scheme does not provide such an operator, but, fortunately, it doesn't
have to because we can build one ourself.

Our first attempt could be to write a procedure (the primary means of
abstraction in functional programming languages)[fn:4]:
#+BEGIN_SRC scheme :results silent
  (define incr!
    (lambda (x)
      (set! x (+ x 1))))
#+END_SRC

This attempt, however, is failed:
#+BEGIN_SRC scheme :exports both :wrap example
  (define x 1)
  (incr! x)
  x
#+END_SRC

#+RESULTS:
#+begin_example
1
#+end_example

The reason that it doesn't work --- the variable's value is still 1
and not 2 --- is that ~(incr! x)~ is a normal combination as
introduced earlier.  As the arguments are evaluated first and the
procedure is called with their values, in this example, ~incr!~ is
called with the argument ~1~.  This is then bound to a new variable
~x~ locally to ~incr!~.  It is this variable, which is increased by 1
and not the top-level variable.

The solution is, of course, to define ~incr!~ not as a procedure[fn:2]
but as a keyword.  In the Scheme programming language, the
~define-syntax~ keyword can be used for it:

#+BEGIN_SRC scheme :exports :results silent
  (define-syntax incr!
    (syntax-rules ()
      ((incr! x)
       (set! x (+ x 1)))))
#+END_SRC

This definition says that ~incr!~ is defined to be a new keyword,
implemented as a macro.  The ~syntax-rules~ line shall be viewed as
boilerplate for the moment (and we will come back to it later).
Important are the next two lines.  The form ~(incr! x)~ is a pattern
saying that the macro matches against a use of the form ~(keyword
form)~ (where ~keyword~ is necessarily ~incr!~).  When the macro is
used, the pattern variable ~x~ is bound to the ~form~.  The form
~(set! x (+ x 1))~ is a template.  When the macro is used, the pattern
variables in the template are replaced with the forms they are bound
to and the substituted template is then used in place of the macro.

In the following example, ~(incr! y)~ is effectively substituted by
~(set! y (+ y 1))~, so we have achieved what we wanted[fn:3]:

#+BEGIN_SRC scheme :exports both :wrap example
  (define y 10)
  (incr! y)
  y
#+END_SRC

#+RESULTS:
#+begin_example
11
#+end_example

As a side note, we see from the discussion that ~set!~ is another
keyword (like ~if~, it cannot be a procedure for the same reasons why
our attempt to write ~incr!~ as a procedure doesn't work).

As any other identifier in Scheme, the identifier ~set!~ can also be
rebound as in the following example:

#+BEGIN_SRC scheme :exports both :wrap example
  (let ([set! (lambda (x y) (+ x y))])
    (define x 1)
    (set! x 2))
#+END_SRC

#+RESULTS:
#+begin_example
3
#+end_example

In the body of the ~let~ form, ~set!~ has lost its usual meaning and
is bound to a procedure adding its two arguments.  It is most
interesting to see what happens when we use our ~incr!~ macro, which
refers to ~set!~, in the body of the ~let~ form:

#+BEGIN_SRC scheme :exports both :wrap example
  (let ([set! (lambda (x y) (/ 1 0))])
    (define x 1)
    (incr! x)
    x)
#+END_SRC

#+RESULTS:
#+begin_example
2
#+end_example

This example yields the correct result ~2~, although calling ~set!~
within the ~let~ body would raise an exception.  The reason for this
is the already mentioned hygiene of Scheme macros.  The identifier
~set!~ in the output of the ~incr!~ macro didn't occur in its input
but came from the macro definition.  Scheme macro hygiene now ensures
that it still refers to the lexical binding it had where it occured in
the program source.  Note that the C preprocessor --- as an example
for a very simple, if not primitive macro facility --- wouldn't have
ensured it.  Whether a C macro works correctly or not often depends on
the lexical environment of the macro use site.

We say that hygienic Scheme macros are referentially transparent.
This is already known from procedures in functional programming
languages and lexical scoping:

#+BEGIN_SRC scheme :results scalar :exports both :wrap example
  (define f
    (let ([x 1])
      (lambda () x)))

  (list (f)
        (let ([x 2])
          (f)))
#+END_SRC

#+RESULTS:
#+begin_example
(1 1)
#+end_example

Wherever the procedure ~f~ is called, it always evaluates to ~1~.

We finish this subsection with another example of hygiene:

#+BEGIN_SRC scheme :exports both :wrap example
  (let ([set! 2])
    (incr! set!)
    set!)
#+END_SRC

#+RESULTS:
#+begin_example
3
#+end_example

The result, which is the increment of the original value of the
variable ~set!~ by one, can again be explained by hygiene and by
distinguishing the identifier ~set!~ that appears in the macro use and
the same-named identifier ~set!~ appearing in the macro source.
Without distinguishing both, the macro use ~(incr! set!)~ is
transcribed to ~(set! set! (+ set! 1))~.  In this transcription, the
first ~set!~ originates from the macro transformer and thus still
refers to the lexical binding it had at that place.  The other two
occurrences of ~set!~ are copies from the macro input and thus refer
to the lexical binding of ~set!~ as a let-bound variable.

*** TODO Demonstrate macro that expands into itself.

** TODO A tracing ~let~

Simple loops are often written using the named ~let~ form as in the following example:
#+BEGIN_SRC scheme :results silent
  (define fact
    (lambda (n)
      (let f ([n n] [a 1])
        (if (zero? n)
            a
            (f (- n 1) (* a n))))))
#+END_SRC

In order to facilitate debugging, let us define a version of the named
~let~ form that prints the arguments with which the loop recursion is
entered and with which it is exited[fn:5].  As ~let~ is a special
form, this has to be a special form as well, so let us write our second macro:

#+BEGIN_SRC scheme :results silent
  ;; A form of a named let that prints information about each recursive
  ;; call.
  (define-syntax trace-let
    (syntax-rules ()
      [(trace-let name ([var expr] ...) body1 ... body2)
       (let f ([depth 0] [var expr] ...)
         (define name
           (lambda (var ...)
             (f (+ depth 1) var ...)))
         (indent depth)
         (display "(")
         (display 'name)
         (begin
           (display " ")
           (display var))
         ...
         (display ")")
         (newline)
         (call-with-values
             (lambda ()
               body1 ... body2)
           (lambda val*
             (indent depth)
             (fold-left
              (lambda (sep val)
                (display sep)
                (display val)
                " ")
              "" val*)
             (newline)
             (apply values val*))))]))

  ;; Helper procedure referenced by the macro output of the macro above.
  (define indent
    (let ([pattern "| "])
      (lambda (depth)
        (do ([i 0 (+ i 1)])
            ((> i depth))
          (display (string-ref pattern (mod i 2)))))))
#+END_SRC

In this macro, the pattern is given by ~(trace-let name ([var expr]
...) body1 ... body2)~, while the template makes up the bulk of the
macro.  Already in the pattern, we see a new syntax, the ellipsis
~...~.  It means that the subpattern preceding it may appear repeated
zero or more times in the input.  When such a subpattern is matched,
the contained pattern variables represent lists of forms.

In the template, the ellipsis means to repeat the preceding
subtemplate as many times as the pattern variables contained in it
represent forms.  For this to work, every such subtemplate has to
contain at least one pattern variable, obviously, and all pattern
variables contained in it have to represent lists of forms of the same
length.

Note the occurrence of ~begin~ in the macro.  Normally, in a procedure
body, ~(begin expression ...)~ is equivalent to the list of
~expressions~, here, however, we have to use it.  The reason is that
following ellipsis refers the immediately preceding subtemplate, so it
is crucial that the two display commands (which we both want to
repeated once per variable) appear in a single form.

When we run the following test, we see the given result printed.

#+BEGIN_SRC scheme :exports both :results output :wrap example
  (define fact
    (lambda (n)
      (trace-let f ([n n])
        (if (zero? n)
            1
            (* (f (- n 1)) n)))))
  (fact 3)
#+END_SRC

#+RESULTS:
#+begin_example
|(f 3)
| (f 2)
| |(f 1)
| | (f 0)
| | 1
| |1
| 2
|6
#+end_example

The ellipsis can also be used to turn our ~incr!~ macro into one that
accepts more than one variable to increment:

#+BEGIN_SRC scheme :results silent
  (define-syntax incr!
    (syntax-rules ()
      ((incr! x ...)
       (begin
         (set! x (+ x 1))
         ...))))
#+END_SRC

Let us briefly test our new extended macro:

#+BEGIN_SRC scheme :results scalar :exports both :wrap example
  (define x 10)
  (define y 20)
  (incr! x y)
  (list x y)
#+END_SRC

#+RESULTS:
#+begin_example
(11 21)
#+end_example

The role of ~begin~ in the macro definition of the extended ~incr!~
differs from the role in our previous use of ~begin~.  Here it is used
to solve the problem that the template that prescribes the macro
output has to be a single form.

One can also write the multi-variable ~incr!~ macro without the
ellipsis by letting the macro expand into itself.  This is not
necessarily how one would do it, but here it serves as a demonstration
for further macro techniques:

#+BEGIN_SRC scheme :results silent
  (define-syntax incr!
    (syntax-rules ()
      ((incr!)
       (values))
      ((incr! x . x*)
       (begin
         (set! x (+ x 1))
         (incr! . x*)))))
#+END_SRC

First of all, this is our first macro with two transcription /rules/,
where each rule consists of a pattern and of a template.  The pattern
of the first rule is ~(incr!)~, the pattern of the second rule is
~(incr! x . x*)~.  Scheme's macro expander tries to match the macro
input against the patterns in the order in which the patterns appear
in the ~syntax-rules~ form.

The second new thing is a a pattern of the form ~(incr! x . x*)~,
which matches an (improper) list of at least two elements, the first
being the macro keyword and the second one being bound to the pattern
variable ~x~.  The rest arguments are bound as an (improper) list to
the pattern variable ~x*~.

Finally, this example demonstrates a recursive macro, that is a macro
that transforms the input into an instance of itself.  As long as the
output of a macro use involves a new macro use (possibly with the same
keyword), the Scheme expander continues with transcribing the macro.

Let us not forget to test the new version of the macro:

#+BEGIN_SRC scheme :results scalar :exports both :wrap example
  (define x 100)
  (define y 200)
  (incr! x y)
  (list x y)
#+END_SRC

#+RESULTS:
#+begin_example
(101 201)
#+end_example

** TODO Accessing vector locations through variables

A /vector/ in Scheme is a collection of locations in the store that
can be linearly addressed.  A new vector can be allocated with the
~vector~ procedure:

#+BEGIN_SRC scheme :results scalar :exports both :wrap example
  (define v (vector 1 2 3))
  v
#+END_SRC

#+RESULTS:
#+begin_example
#(1 2 3)
#+end_example

Vector elements can be retrieved using ~vector-ref~ and mutated using ~vector-set!~:

#+BEGIN_SRC scheme :results scalar :exports both :wrap example
  (vector-ref v 2)
#+END_SRC

#+RESULTS:
#+begin_example
3
#+end_example

#+BEGIN_SRC scheme :results scalar :exports both :wrap example
  (vector-set! v 1 4)
  v
#+END_SRC

#+RESULTS:
#+begin_example
#(1 4 3)
#+end_example

Assume that we want to use our ~incr!~ macro to increase the value of
one vector element.  As ~incr!~ expects a variable as its argument, we
have make the locations associated to a vector accessible as if they
were backed up by a variable.  Another feature of the (R6RS) macro
system comes to our rescue:

#+BEGIN_SRC scheme :results scalar :exports both :wrap example
  (define-syntax v1
    (identifier-syntax
     [v1 (vector-ref v 1)]
     [(set! v1 expr) (vector-set! v 1 expr)]))
  (incr! v1)
  v
#+END_SRC

#+RESULTS:
#+begin_example
(5 #(1 5 3))
#+end_example

This macro isn't written with ~syntax-rules~ but uses
~identifier-syntax~.  This is used to declare a keyword, ~v1~ in our
case, that is transcribed differently, depending on whether it appears
in the form ~v1~ or in the form ~(set! v1 expr)~ in the source code.

* TODO Syntax objects

** TODO Identifiers

** TODO Deconstructing syntax objects

** TODO Constructing syntax objects

* TODO Syntax-case macros

** TODO A fluid ~let~

** TODO Macro-generating macros

* TODO Breaking hygiene

** TODO A pitfall

* TODO Phasing

* TODO Extensions

** TODO Syntax parameters

** TODO Identifier properties

* TODO Examples

** TODO Implementing a DSL

* Footnotes

[fn:5]Such a form is predefined in Chez Scheme, but is not part of the
Scheme standard.  In fact, Chez Scheme's version properly handles tail
calls, which our simple version doesn't.
[fn:4]While Scheme does not forbid mutation (like ML but unlike
Haskell), the pitfalls of impure code are well-understood.  Therefore,
the names of Scheme procedures and syntax that modifies locations in
the store (the Scheme model of the computer's memory) end with a ~!~
by convention.

[fn:3]When interactively testing our procedures and syntax (keywords),
one has to be careful that we have given both the procedure and the
keyword the same name.  Evaluating one of the definitions will
overwrite the meaning of the other one.

[fn:2]More precicely: as a variable holding a procedure value.

[fn:1]This may change when the R7RS-large standardization effort is
finished.  Both, R6RS and R7RS-small, are successors (and extensions)
to R5RS (1998), but R7RS-small was never meant to be seen in isolation
as a successor to R6RS.  Time will tell whether the R7RS large
language will be able to replace R6RS when it is finally done.  It is
planned to include the R6RS macro facility in R7RS-large.
